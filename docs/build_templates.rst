.. _build_templates:

==================
Building Templates
==================

Template design considerations
==============================

Typical report template design will require external resources, such as Javascript libraries and web fonts. These resources
can be added locally or referenced externally from eg. CDNs, as any regular web page. However, keep in mind that referencing
external resources may pose a security risk, and requires internet access when generating PDFs.

Having these resources locally will reduce the PDF rendering time and minimize or eliminate the need to have internet access,
but will increase the packaged report size and the effort required to maintain reports. Some assets may also have licensing
limitations that prevent usage and redistribution in a packaged format.

The recommended approach depends on the use case. Reports where PDF rendering time is not critical can reference resources
externally as needed; Reports where rendering time is critical (such as generated in response to a user interaction) should
have these resources referenced locally, as much as possible.


ZipReport Jinja considerations
==============================

ZipReport allows most Jinja features, including adding your own filters. However, you can only import templates within
your report folder path (including subfolders). Adding extensions to Jinja is also supported, when using the JinjaRender
class directly. It works by instantiating :class:`zipreport.template.JinjaRender<zipreport.template.jinjarender.JinjaRender>` with
the required options:

.. code-block:: python

    from zipreport.report import ReportFileLoader
    from zipreport.template import JinjaRender

    # load report from file
    zpt = ReportFileLoader.load("simple.zpt")

    # extensions for jinja usage
    jinja_options = {
        "extensions": ['jinja2.ext.i18n'],
    }

    # initialize JinjaRender() with the desired options
    renderer = JinjaRender(zpt, jinja_options)

CSS considerations
==================

When using the zipreport electron-based processors (zipreport-cli, zipreport-server), be aware that the media type *print*
will be used for PDF generation.


Waiting for Javascript execution before rendering
=================================================

Some reports may contain complex Javascript logic for page composition, and timing the finalization of these operations
are a challenge. ZipReport provides a more reliable alternative to relying on waiting a predefined amount of time before triggering the render -
a Javascript event notification system that explicitly notifies the Electron application that client-side rendering is
finalized and PDF generation can be done.

The notification mechanism works by dispatching an event named 'zpt-view-ready'. As an example, this can be used to signal
paged.js end of operations:

.. code-block:: html

    <!DOCTYPE html PUBLIC>
    <html lang="en" lang="en">
      <head>
        <script src="https://s3.amazonaws.com/pagedmedia/pagedjs/dist/paged.js"></script>
        <script>
            // custom paged.js handler
            class handlers extends Paged.Handler {
                constructor(chunker, polisher, caller) {
                    super(chunker, polisher, caller);
                }

                afterPreview(pages) {
                    // dispatch event signaling readiness for PDF generation
                    document.dispatchEvent(new Event('zpt-view-ready'))
                }
            }

            // Register handler on paged.js library
            Paged.registerHandlers(handlers);
        </script>
      </head>
    <body>


Generating images dynamically
=============================

ZipReport provides several filters that allow the generation and inclusion of images generated in runtime, without requiring
client-side composition. This is quite useful to add data-driven graphics to the reports, both for PDF and MIME generation.

The image is generated by calling a function that will save the results to a io.BytesIO memory buffer. This buffer will
be added to the in-memory representation of the report file as an image with a random name by the filter, and then the
appropriate html image tag will be generated, for rendering purposes.

Bundled Jinja filters for images
--------------------------------

================ =============================
Filter name      Description
================ =============================
png              Generates dynamic PNG image
gif              Generates dynamic GIF image
jpg              Generates dynamic jpeg image
svg              Generates dynamic svg image
================ =============================


Call syntax:

.. code-block::

    Positional args:
        {{ callable | filter(data_source, alt_text, width, height, css_class }}

    Named args:
        {{ callable | filter(data=data_source, alt=alt_text, width=width, height=height, class=css_class }}

Where:

=========== ==============================================================================================
Name        Description
=========== ==============================================================================================
callable    function that will generate the specific graphic; it is passed as a template variable
filter      bundled jinja filter to generate the appropriate img tag; see below for available filters
data_source variable with data to be passed to the callable as a parameter
alt_text    optional img tag alt text
width       optional image tag width
height      optional image tag height
css_class   optional image tag css classes
=========== ==============================================================================================


Writing an image generation function for an image filter
--------------------------------------------------------

Writing a function to be used dynamically in the report is quite simple; it is a regular function that receives
an argument and returns a io.BytesIO buffer object.

Below we'll see a complete example on how to generate and embed a simple image on a template.  The complete code is
available on the examples/filter_simple folder.

Example file list:

.. code-block:: shell

    sample_report/index.html
    sample_report/manifest.json
    main.py

We start with a simple html template and a manifest file into the sample_report folder:

Html template (index.html):

.. code-block:: html

    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Zipreport jinja filter example</title>
    </head>
    <body>
    <h1>PNG Example</h1>
    {{ colored_rectangle_fn|png(rectangle_color, "label for png") }}
    </body>
    </html>

Manifest file(manifest.json):

.. code-block:: json

    {
      "author": "zipreport",
      "title": "Jinja Filter example",
      "description": "Dynamic jinja filter example",
      "version": "1.0",
      "params": [
        "colored_rectangle_fn",
        "rectangle_color"
      ]
    }

We can now build the report:

.. code-block:: shell

    $ zipreport build sample_report

    == Building Report simple_report.zpt ==
    Checking manifest & index file...
    Building...
    Copying manifest.json...
    Copying index.html...
    Generating simple_report.zpt...
    Done!

Then, we start writing our main.py code. First, we create our image generation function. This function will generate
a png colored rectangle using PIL, based on the specified color passed as argument (in this case, the value will
come from the rectangle_color template variable), and returns a io.BytesIO buffer.

.. code-block:: python

    import io
    from PIL import Image

    def render_image(color='red') -> io.BytesIO:
        # generate a rectangle with the specified color
        img = Image.new('RGB', (256, 256), color=color)
        # save generated image to a memory buffer
        buffer = io.BytesIO()
        img.save(buffer, format='PNG')
        # rewind to the beginning of the buffer
        buffer.seek(0)
        return buffer


Lastly, we add some boilerplate to load, process and save the report. This example relies on zipreport-cli for rendering
(Some additional validations were omitted for readability):

.. code-block:: python

    if __name__ == "__main__":

        args = sys.argv[1:]
        zipreport_cli = Path(args[0])  # zipreport-cli binary path
        pdf_name = Path(args[1])  # output file path

        report_name = "simple_report.zpt"
        report = ReportFileLoader.load(report_name)

        # template variables
        report_data = {
            # our callback function to generate the image
            'colored_rectangle_fn': render_image,
            # desired color to use
            'rectangle_color': 'pink',
        }

        # render using zipreport-cli processor
        result = ZipReportCli(zipreport_cli).render_defaults(report, report_data)
        if not result.success:
            print("An error occured while generating the pdf:", result.error)
            exit(1)

        # save io.BytesIO buffer to file
        with open(pdf_name, 'wb') as f:
            f.write(result.report.read())

We can now run our example program:

.. code-block:: shell

    $ python3 main.py /opt/zpt-cli/zpt-cli result.pdf
    Converted 'file:///tmp/tmpogw5b5cs/report.html' to PDF: 'report.pdf'
    Elapsed Time: 792.996ms
    Report generated to result.pdf
    $

Expected result contents:

.. image:: /img/simple_report1.png
    :alt: PDF generated from the example

Using placeholders for previewing purposes
__________________________________________

Due to the dynamic nature of the dynamic image generation, it is not possible to preview the report correctly with *zipreport debug*.
To work around this limitation, it is possible to specify a placeholder image (local or remote) instead of the callable parameter.
The data source parameter, while mandatory, is ignored.

Following on the previous example, we can add a data.json to simple_report1 with a string url for an image instead of the callable
function. This url can either be external (ex. a placeholder generation site) or local (a local image within the template
structure):

data.json contents with a placeholder url:

.. code-block:: json

    {
      "colored_rectangle_fn": "https://via.placeholder.com/256/f99.png",
      "rectangle_color": ""
    }


data.json contents with a local image:

.. code-block:: json

    {
      "colored_rectangle_fn": "/images/png_graphic.png",
      "rectangle_color": ""
    }


Page numbers, headers and footers
---------------------------------

TBD

Generating table of contents
----------------------------

TBD
